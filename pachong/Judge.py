
import pandas as pd
import numpy as np
def judge_func(curve2, Ce, C_ygz, xm):
        """
            curve2: array[1x350]
            Ce: str Batch Name 
            C_ygz = C值

        """
        reason=np.zeros((1,9))  #判定（九重标准）


        ##输入 1*350的数据 curve2=np.array([1,2,3,……,350])
        #例：curve2=np.array([1,2,3,4,51,56,1564,564,987,98,5])
      


        curve2_hang = len(curve2)   #350个数据点
        curve2_lie = 1 #数据条目数,1




        #第九条无效判定标准:测试项目选定错误 
        reason[0][8]=1
        if xm=='  TEST\t' or xm=='  test\t' or xm=='  ceshi\t' or xm=='  CESHI\t':
            reason[0][8]=0#第九条无效判定标准，测试项目错误     




        ##ce 的计算
        ce=1# 默认单测
        s=Ce
        ce=s.count('A')+s.count('B')+s.count('C')
        if ce<1 or ce>3:
            ce=1   
        del Ce#删除Ce


        # In[8]:


        ## 输入C、T1~T3参考值，从小到大输入！！
        ck=np.array([[190,290,0,0],[115,200,280,0],[67,146,217,294],[125,245,0,0]]);# 老的单测
        sit_C=np.array([0,2,3,0]); # C的位置


        # In[9]:


        ##数据的归一化处理
        curveToOne2=np.zeros((curve2_lie,curve2_hang))  
        zxz=min(curve2)
        zdz=max(curve2)   
        for j in range (curve2_hang):
            fenmu=(zdz-zxz)
            if fenmu==0:
                fenmu=0.1    
            curveToOne2[0][j]=(curve2[j]-zxz)/fenmu
        curveToOne2=curveToOne2.T


        # In[10]:


        # 曲线数据光滑化
        from scipy.signal import savgol_filter
        a = curve2
        curve2=savgol_filter(a,5,4)


        # In[11]:


        ##记录峰的出现位置f，判断峰的个数F
        error=[];
        bd=6;  #区间波动
        ad=[curveToOne2[curve2_hang-1]]
        for i in range (bd*2):#矩阵扩展
            curveToOne2=np.r_[curveToOne2, ad]
        h1=0.0025;  #峰区域的阈值 
        h2=0.01; #非峰区域的阈值
        f=np.zeros((len(curveToOne2),len(curveToOne2[1])));
        H=np.zeros((len(curveToOne2),len(curveToOne2[1])));
        F=np.zeros((len(curveToOne2[1]),2));


        # In[12]:


        ##波峰判别（波峰矫正）   
        j=0;
        for i in range(bd,curve2_hang+bd):   
        
            ## 确定峰判断标准
            
            h=h2; #高标准状态为非峰区域时候
            
            for ii in range (int(ce)+1):
                if ck[(int(ce)-1)][ii]-30<=i & i<=ck[(int(ce)-1)][ii]+30:  #i:处于参考峰区域时候，采用低标准
                    h=h1;
            H[i][j]=h;
            
            ## 顶峰判断
            if (curveToOne2[i][j]>(curveToOne2[i-bd][j]+H[i][j])) & (curveToOne2[i][j]>(curveToOne2[i+bd][j]+H[i][j])) & ((curveToOne2[i-1][j]<=curveToOne2[i][j])):
                f[i][j]=1;
                f[i-1][j]=0;  
                
            #判断是不是老单测标准

                findfind=f[:,j];
                if sum(f[:,j])==2:
                    sitfindfind=np.argwhere(findfind)
                    if (abs(sitfindfind[0]-ck[3][0])<30==1) or (abs(sitfindfind[1]-ck[3][1])<30==1):
                        ce[j]=4;


        ## 尾巴处理   
            if (ce<4)  & (i>(ck[int(ce-1)][int(ce)])+30):
                f[i][j]=0;
            
            if (ce==4) & (i>ck[3][1]+30):
                f[i][j]=0;
        
        ## 中间处理
            if ce==4:
                if sum(curveToOne2[165:225,j])/60<0.15:
                    f[165:225,j]=0;
                ce=1;
        
        ## 头部处理
        f[1:20,:]=0; 
        ## 结果统计
        F[j][0]=sum(f[:,j]);   #峰的个数


        # In[13]:


        ## 删除扩展的行 
        for i in range (bd*2):
            curveToOne2 = np.delete(curveToOne2, curve2_hang+bd*2-i-1, 0)  
            f= np.delete(f, curve2_hang+bd*2-i-1, 0)
            H= np.delete(H, curve2_hang+bd*2-i-1, 0)




        ff=np.zeros((curve2_lie,4));#记录四个位点是否有峰
        sit=np.zeros((curve2_lie,4)); #最大的合适峰数，要么为单测=2，要么三侧=4
        for j in range (curve2_lie):#(j=0,本程序就一条数据)

            
            if (1<F[j][0]) & (F[j][0]<4):#判断峰在1-4之内才继续判定。
                k=0;
                p=0;
                for i in range (curve2_hang):
                    if f[i][j]==1:
                        line=F[j][0]-2;#(ck中的行数)
                        xian=k#(ck第line行中的中第k个值)
                        if (abs(i-(ck[int(line)][int(xian)]))<20):#与预估线在20以内
                            p=p+1;
                        k=k+1;#f中计算过的1的个数+1
                            
                if p==F[j][0]:#算出来的峰值坐标与预估的峰值坐标相差20以内
                    ce=F[j][0]-1;   #让测试项目和实际峰数保持对应
                    
        
            if F[j][0]<=1+ce: #一定要有ce+1个峰 才执行
                reason[j][0]=1;#记录失效原因，1表示通过。第一关卡：峰数匹配。
                k=0;
                for i in range (curve2_hang):
                    if f[i][j]==1:    
                        sit[j][k] = i 
                        k=k+1
            
                for m in range (4): #单双三测 判断C、T1~T3位点是否有峰
                    if (ck[0][m]!=0) &(1<=F[j][0]) & (F[j][0]<=2) & (abs(sit[j][m]-ck[0][m])<=20):
                        ff[j][m]=1;  #记录位点m是否出现峰
                        continue;
                    if (ck[1][m]!=0) &(2<=F[j][0]) & (F[j][0]<=3) & (abs(sit[j][m]-ck[1][m])<=20):
                        ff[j][m]=1;  #记录位点m是否出现峰 
                        continue;
                    if (ck[2][m]!=0) &(3<=F[j][0]) & (F[j][0]<=4) & (abs(sit[j][m]-ck[2][m])<=20):
                        ff[j][m]=1;  #记录位点m是否出现峰 
                        continue;
                    if (ck[3][m]!=0) &(1<=F[j][0]) & (F[j][0]<=2) & (abs(sit[j][m]-ck[3][m])<=20):
                        ff[j][m]=1;  #记录位点m是否出现峰
                        continue;
                
            
                F[j][1]=sum(ff[j,:]);  #记录总峰数、四个位点峰和
        




        #判断有效无效
        true=np.zeros((curve2_lie,1))
        for j in range (curve2_lie):#(j=0,本程序就一条数据)
        ## 关卡判断

            if C_ygz>=75: #有效试剂检测
                reason[j][1]=1;#记录失效原因，1表示通过。第二关卡：荧光值匹配。
            if (ff[j][sit_C[int(ce-1)]]==1) & (F[j][0]<=ce+1): #如果C的位置有峰，总峰数位于1~2
                reason[j][2]=1;#第三关卡：C位存在峰匹配。
            
        
        
            if sit[j][sit_C[int(ce-1)]]>0: #怕没有sit
                if max(curveToOne2[1:30,j])<curveToOne2[int(sit[j][sit_C[int(ce-1)]])]:   #左边出现比位点C峰值高的,代码解释：j的测的C的序号的C的位置的曲线数据
                        reason[j][3]=1;#第四关卡；曲线要比位点C要低，不然就是未跑完
            
        
        
            if sum(curveToOne2[0:int(sit[j][sit_C[int(ce-1)]]-30),j]>0.2)<sit[j][sit_C[int(ce-1)]]-30: #可能有几个意外
                reason[j][4]=1;#第五关卡；底线要低，不然就是受潮了,但允许存在先升后降
        
        
            if sit[j][sit_C[int(ce-1)]]>0: #怕没有sit
                if (np.mean(curveToOne2[ck[int(ce-1)][0]+30:ck[int(ce-1)][1]-30,j])<0.3) | ((F[j][0]==2) & (np.mean(curveToOne2[ck[3][0]+30:ck[3][1]-30,j])<0.3)):                               
                    reason[j][5]=1;#第六关卡；中间要低,平均不能超过0.3
            
        
            if sum(curveToOne2[320:340,j])<20*0.3:
                reason[j][6]=1;  #尾巴不能高 曲线1732
        
        
            # 新版单测     前2 < 前1+每个差距0.06
            reason[j][7]=1;    
            if (ce==1) & (abs(sit[j][0]-ck[3][0])<30) & (sum(curveToOne2[75:125,j])<sum(curveToOne2[25:75,j])+0.3):
                reason[j][7]=0;  #疑似开头2有肿块
        
        
        ## 有效判断+有效类型判断

            if sum(reason[j])==len(reason[j]): #得分=关卡数（全对）
                true[j]=1; #有效
            
            # print(true)
            return true

if __name__ == '__main__':
    
    xm='  甲基安非他明/吗啡'
    Ce='ABCC'
    #输入荧光值
    C_ygz=1223
    ##输入 1*350的数据 curve2=np.array([1,2,3,……,350])
    #例：curve2=np.array([1,2,3,4,51,56,1564,564,987,98,5])
    curve2=np.array([45028,44985,44977,44970,44955,44992,45035,45043,45050,45065,45038,45004,44983,44946,44906,44871,44837,44798,44774,44744,44713,44675,44654,44608,44568,44530,44489,44425,44380,44335,44281,44243,44233,44204,44180,44169,44146,44109,44086,44057,44047,44014,44003,43991,43991,43983,44031,44058,44109,44157,44223,44242,44286,44327,44367,44387,44456,44506,44567,44625,44699,44744,44797,44856,44916,44971,45047,45121,45173,45234,45300,45370,45423,45481,45544,45600,45649,45757,45916,46127,46431,46859,47388,48047,48918,49967,51295,52909,54941,57348,60290,63721,67825,72559,78079,84409,91709,99987,109414,120107,132231,145937,161445,178949,198595,220479,244577,270745,298674,327943,358021,388273,418034,446597,473267,497379,518411,535889,549467,558932,564172,565103,561735,554155,542507,527008,508000,485913,461257,434593,406561,377761,348802,320287,292716,266524,242076,219618,199231,180952,164653,150163,137267,125755,115419,106133,97746,90188,83404,77348,71968,67294,63249,59797,56887,54499,52506,50912,49623,48614,47812,47213,46761,46486,46361,46393,46613,47024,47623,48467,49549,50938,52623,54743,57282,60401,64103,68587,73842,80052,87251,95565,105062,115882,128119,141935,157509,174982,194556,216326,240368,266577,294778,324567,355495,386935,418254,448756,477758,504573,528601,549289,566196,578965,587404,591370,590845,585894,576695,563416,546376,525942,502516,476570,448682,419410,389352,359131,329363,300578,273261,247791,224423,203260,184289,167395,152388,139047,127132,116458,106866,98213,90410,83409,77157,71599,66743,62521,58918,55841,53279,51117,49329,47837,46631,45642,44877,44313,43936,43758,43747,43940,44324,44929,45753,46897,48309,50104,52251,54885,57968,61673,66029,71212,77234,84320,92532,102005,112866,125241,139147,154624,171624,190035,209698,230416,251909,273871,295912,317670,338677,358507,376708,392886,406602,417573,425536,430341,431909,430275,425518,417781,407272,394212,378895,361642,342810,322803,302062,281014,260078,239633,220015,201474,184203,168305,153871,140854,129212,118846,109647,101492,94262,87848,82155,77121,72651,68719,65292,62313,59740,57554,55724,54195,52940,51961,51169,50546,50059,49712,49424,49209,49046,48900,48762,48605,48488,48343,48200,48039,47882,47662,47403,47087,46680,46173,45534,44773,43871,42802])
    curve2 = np.zeros(150)

    ret = judge_func(curve2, Ce, C_ygz, xm)
    print(ret)
    